import math
import os
from pathlib import Path
from typing import Iterator

import cv2
import numpy

import const


def получить_пути(папка_с_картинками: str) -> Iterator[Path]:
    содержимое_папки = sorted(os.listdir(папка_с_картинками))

    for каждая_запись in содержимое_папки:
        путь = Path(папка_с_картинками) / каждая_запись

        if all((
                путь.is_file(),
                путь.name.endswith(const.ОБРАБАТЫВАЕМЫЕ_РАСШИРЕНИЯ),
        )):
            yield путь


def обработать_один_файл(путь: Path) -> Iterator[numpy.ndarray]:
    исходная_картинка = прочитать_файл(путь)
    исходная_картинка = повернуть_на_90_по_часовой(исходная_картинка)
    упрощённые_цвета = рассчитать_упрощённый_цвет(исходная_картинка)
    контуры = найти_контуры_в_изображении(упрощённые_цвета)

    for контур in контуры:
        примерный_прямоугольник = cv2.approxPolyDP(
            контур,
            0.01 * cv2.arcLength(контур, True),
            True,
        )

        if len(примерный_прямоугольник) == 4:
            x, y, ширина, высота = cv2.boundingRect(контур)

            if ширина < const.МИНИМАЛЬНАЯ_ШИРИНА:
                continue

            if высота < const.МИНИМАЛЬНАЯ_ВЫСОТА:
                continue

            точка_1 = tuple(примерный_прямоугольник[0][0])
            точка_2 = tuple(примерный_прямоугольник[1][0])
            точка_3 = tuple(примерный_прямоугольник[2][0])
            точка_4 = tuple(примерный_прямоугольник[3][0])

            все_точки = [точка_1, точка_2, точка_3, точка_4]
            отсортированные_точки = отсортировать_точки(все_точки)

            (
                (x_верхний_левый, y_верхний_левый),
                (x_нижний_левый, y_нижний_левый),
                (x_нижний_правый, y_нижний_правый),
                (x_верхний_правый, y_верхний_правый),
            ) = отсортированные_точки

            готовая_картинка = исходная_картинка.copy()

            if const.МНОГОСЛОВНО:
                готовая_картинка = промаркировать_углы(
                    готовая_картинка,
                    x_верхний_левый, y_верхний_левый,
                    x_нижний_левый, y_нижний_левый,
                    x_нижний_правый, y_нижний_правый,
                    x_верхний_правый, y_верхний_правый,
                )

                готовая_картинка = раскрасить(
                    готовая_картинка,
                    контур,
                    x_верхний_левый, y_верхний_левый,
                    x_нижний_левый, y_нижний_левый,
                    x_нижний_правый, y_нижний_правый,
                    x_верхний_правый, y_верхний_правый,
                )

            if const.ДОБАВИТЬ_БЕЛЫЙ_КОНТУР:
                готовая_картинка = добавить_контур(готовая_картинка, контур)

            повёрнутая_картинка = выровнять_по_верхней_грани(
                готовая_картинка,
                x_верхний_левый, y_верхний_левый,
                x_верхний_правый, y_верхний_правый,
            )

            реальная_ширина = рассчитать_расстояние(
                x_верхний_левый, y_верхний_левый,
                x_верхний_правый, y_верхний_правый,
            )

            реальная_высота = рассчитать_расстояние(
                x_верхний_левый, y_верхний_левый,
                x_нижний_левый, y_нижний_левый,
            )

            обрезанная_картинка = обрезать_картинку(
                повёрнутая_картинка,
                x_верхний_левый,
                y_верхний_левый,
                реальная_ширина,
                реальная_высота,
            )

            yield обрезанная_картинка


def прочитать_файл(путь: Path) -> numpy.ndarray:
    исходная_картинка = cv2.imread(str(путь.absolute()))
    return исходная_картинка


def рассчитать_упрощённый_цвет(
        исходная_картинка: numpy.ndarray) -> numpy.ndarray:
    в_серых_тонах = cv2.cvtColor(исходная_картинка, cv2.COLOR_BGR2GRAY)
    _, упрощённый_цвет = cv2.threshold(в_серых_тонах, 50, 255, 0)
    return упрощённый_цвет


def найти_контуры_в_изображении(упрощённые_цвета: numpy.ndarray) -> tuple:
    контуры, _ = cv2.findContours(упрощённые_цвета, cv2.RETR_EXTERNAL, 2)

    if const.МНОГОСЛОВНО:
        print(f'\tНашли {len(контуры)} шт. контуров')

    return контуры


def раскрасить(
        исходная_картинка: numpy.ndarray,
        контур: tuple,
        x_верхний_левый: int, y_верхний_левый: int,
        x_нижний_левый: int, y_нижний_левый: int,
        x_нижний_правый: int, y_нижний_правый: int,
        x_верхний_правый: int, y_верхний_правый: int,
) -> numpy.ndarray:
    радиус = 4
    готовая_картинка = cv2.drawContours(
        исходная_картинка, [контур], -1, const.БИРЮЗОВЫЙ, 3)

    готовая_картинка = cv2.circle(
        готовая_картинка, (x_верхний_левый, y_верхний_левый),
        радиус, const.СИНИЙ, -1)

    готовая_картинка = cv2.circle(
        готовая_картинка, (x_нижний_левый, y_нижний_левый),
        радиус, const.ЗЕЛЁНЫЙ, -1)

    готовая_картинка = cv2.circle(
        готовая_картинка, (x_нижний_правый, y_нижний_правый),
        радиус, const.КРАСНЫЙ, -1)

    готовая_картинка = cv2.circle(
        готовая_картинка, (x_верхний_правый, y_верхний_правый),
        радиус, const.ФИОЛЕТОВЫЙ, -1)

    return готовая_картинка


def промаркировать_углы(
        исходная_картинка: numpy.ndarray,
        x_верхний_левый: int, y_верхний_левый: int,
        x_нижний_левый: int, y_нижний_левый: int,
        x_нижний_правый: int, y_нижний_правый: int,
        x_верхний_правый: int, y_верхний_правый: int,
) -> numpy.ndarray:
    шрифт = cv2.FONT_HERSHEY_SIMPLEX
    масштаб = 1
    цвет = (255, 0, 0)
    толщина = 2

    готовая_картинка = cv2.putText(
        исходная_картинка, 'top-left', (x_верхний_левый, y_верхний_левый),
        шрифт,
        масштаб, цвет, толщина, cv2.LINE_AA)

    готовая_картинка = cv2.putText(
        готовая_картинка, 'top-right', (x_верхний_правый, y_верхний_правый),
        шрифт,
        масштаб, цвет, толщина, cv2.LINE_AA)

    готовая_картинка = cv2.putText(
        готовая_картинка, 'bottom-left', (x_нижний_левый, y_нижний_левый),
        шрифт,
        масштаб, цвет, толщина, cv2.LINE_AA)

    готовая_картинка = cv2.putText(
        готовая_картинка, 'bottom-right', (x_нижний_правый, y_нижний_правый),
        шрифт,
        масштаб, цвет, толщина, cv2.LINE_AA)

    return готовая_картинка


def повернуть_на_90_по_часовой(
        исходная_картинка: numpy.ndarray) -> numpy.ndarray:
    return cv2.rotate(исходная_картинка, cv2.ROTATE_90_CLOCKWISE)


def выровнять_по_верхней_грани(
        исходная_картинка: numpy.ndarray,
        x_верхний_левый: int, y_верхний_левый: int,
        x_верхний_правый: int, y_верхний_правый: int,
) -> numpy.ndarray:
    угол = рассчитать_угол_отклонения_от_горизонтали(
        x_верхний_левый, y_верхний_левый,
        x_верхний_правый, y_верхний_правый,
    )
    высота = исходная_картинка.shape[0]
    ширина = исходная_картинка.shape[1]
    m = cv2.getRotationMatrix2D(
        (int(x_верхний_левый), int(y_верхний_левый)), угол, 1.0)
    rotated = cv2.warpAffine(исходная_картинка, m, (ширина, высота))
    return rotated


def обрезать_картинку(
        исходная_картинка: numpy.ndarray,
        x: int,
        y: int,
        ширина: int,
        высота: int,
) -> numpy.ndarray:
    обрезанная_картинка = исходная_картинка[y: y + высота, x: x + ширина]
    return обрезанная_картинка


def рассчитать_расстояние(x1, y1, x2, y2) -> int:
    dis = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
    return math.ceil(dis)


def рассчитать_угол_отклонения_от_горизонтали(
        x_верхний_левый: int, y_верхний_левый: int,
        x_верхний_правый: int, y_верхний_правый: int,
) -> float:
    горизонтальный_катет = abs(x_верхний_правый - x_верхний_левый)
    вертикальный_катет = abs(y_верхний_правый - y_верхний_левый)
    угол = math.atan(вертикальный_катет / горизонтальный_катет) * 180 / math.pi
    if y_верхний_правый < y_верхний_левый:
        множитель = -1
    else:
        множитель = 1
    return угол * множитель


def отсортировать_точки(
        все_точки: list[tuple[int, int]]) -> list[tuple[int, int]]:
    наименьший_х = min(x for x, y in все_точки)
    наибольший_х = max(x for x, y in все_точки)
    наименьший_y = min(y for x, y in все_точки)
    наибольший_y = max(y for x, y in все_точки)

    x_верхний_левый = y_верхний_левый = -1
    x_нижний_левый = y_нижний_левый = -1
    x_нижний_правый = y_нижний_правый = -1
    x_верхний_правый = y_верхний_правый = -1

    середина_х = (наименьший_х + наибольший_х) / 2
    середина_y = (наименьший_y + наибольший_y) / 2

    for x, y in все_точки:
        if x < середина_х and y < середина_y:
            x_верхний_левый = x
            y_верхний_левый = y
        elif x < середина_х and y > середина_y:
            x_нижний_левый = x
            y_нижний_левый = y
        elif x > середина_х and y > середина_y:
            x_нижний_правый = x
            y_нижний_правый = y
        elif x > середина_х and y < середина_y:
            x_верхний_правый = x
            y_верхний_правый = y
        else:
            raise

    return [
        (x_верхний_левый, y_верхний_левый),
        (x_нижний_левый, y_нижний_левый),
        (x_нижний_правый, y_нижний_правый),
        (x_верхний_правый, y_верхний_правый),
    ]


def добавить_контур(
        исходная_картинка: numpy.ndarray,
        контур: tuple,
) -> numpy.ndarray:
    готовая_картинка = cv2.drawContours(
        исходная_картинка, [контур], -1, const.БЕЛЫЙ, const.ШИРИНА_КОНТУРА)
    return готовая_картинка


def сохранить_картинку_в_новый_файл(
        готовая_картинка: numpy.ndarray,
        номер_картинки: int,
        имя_исходного_файла: str,
        папка_с_картинками: Path,
) -> None:
    расширение = имя_исходного_файла.rsplit('.', maxsplit=1)[-1]
    имя_нового_файла = f'_{номер_картинки:04d}.{расширение}'
    cv2.imwrite(str(папка_с_картинками / имя_нового_файла), готовая_картинка)
